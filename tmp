import json
import string
import subprocess
from datetime import datetime
import sqlite3
import time

import aiosqlite

import buttons
import dbworker

from telebot import TeleBot
from pyqiwip2p import QiwiP2P
from pyqiwip2p import AioQiwiP2P
from telebot import asyncio_filters
from telebot.async_telebot import AsyncTeleBot
import emoji as e
import asyncio
import threading
from telebot import types
from telebot.asyncio_storage import StateMemoryStorage
from telebot.asyncio_handler_backends import State, StatesGroup

from datetime import datetime
from pytz import timezone

from buttons import main_buttons
from dbworker import User


from translations import translations
#from messages import messages

with open("config.json", encoding="utf-8") as file_handler:
    CONFIG=json.load(file_handler)
    dbworker.CONFIG=CONFIG
    buttons.CONFIG=CONFIG
with open("texts.json", encoding="utf-8") as file_handler:
    text_mess = json.load(file_handler)
    texts_for_bot=text_mess


DBCONNECT="data.sqlite"
BOTAPIKEY=CONFIG["tg_token"]

bot = AsyncTeleBot(CONFIG["tg_token"], state_storage=StateMemoryStorage())
#QIWI_PRIV_KEY = CONFIG["qiwi_key"]

#p2p = AioQiwiP2P(auth_key=QIWI_PRIV_KEY,alt="zxcvbnm.online")


########
import aiosqlite

async def get_user_language(user_id):
    async with aiosqlite.connect(DBCONNECT) as db:
        async with db.cursor() as cursor:
            await cursor.execute("SELECT language FROM userss WHERE tgid = ?", (user_id,))
            result = await cursor.fetchone()

    if result is not None:
       return result[0]
    #else:
    #   return "ua"




class MyStates(StatesGroup):
    findUserViaId = State()
    editUser = State()
    editUserResetTime = State()

    UserAddTimeDays = State()
    UserAddTimeHours = State()
    UserAddTimeMinutes = State()
    UserAddTimeApprove = State()

    AdminNewUser = State()

#async def next_menu(language, callback_query, callback_query_userid, user_dat):

#          text = translations[language]
#          await bot.send_message(callback_query, e.emojize(texts_for_bot[language]["hello_message"]),parse_mode="HTML",reply_markup=await main_buttons(user_dat,language))
#          await bot.send_message(callback_query, e.emojize(texts_for_bot[language]["trial_message"]), )
          #Language = text["Language"]
          #await bot.send_message(callback_query, text=str(Language),parse_mode="HTML",reply_markup=await buttons.main_buttons1(user_dat, language, callback_query_userid))


@bot.message_handler(commands=['start'])
async def start(message:types.Message):

    user_id = message.from_user.id
    language = message.from_user.language_code
    text = translations[language]

    if message.chat.type == "private":
        await bot.delete_state(message.from_user.id)
        user_dat = await User.GetInfo(message.chat.id)
        if user_dat.registered:

            await bot.send_message(message.chat.id,"Информация о подписке",parse_mode="HTML",reply_markup=await main_buttons(user_dat,language))
            await bot.send_message(message.chat.id,"Информация о подписке",parse_mode="HTML",reply_markup=await buttons.main_buttons1(user_dat,language,message.chat.id))

        else:
            try:
                username = "@" + str(message.from_user.username)
            except:

                username = str(message.from_user.id)

            await user_dat.Adduser(username,message.from_user.full_name)
            user_dat = await User.GetInfo(message.chat.id)
            await bot.send_message(message.chat.id,e.emojize(texts_for_bot["hello_message"]),parse_mode="HTML",reply_markup=await main_buttons(
user_dat,language))
            await bot.send_message(message.chat.id,e.emojize(texts_for_bot["trial_message"]))


#@bot.message_handler(commands=['start'])
#async def start(message:types.Message):

#    user_id = message.from_user.id
#    language = message.from_user.language_code
#    text = translations[language]
    #msg = messages[language]


#    if message.chat.type == "private":
#        await bot.delete_state(message.from_user.id)
#        user_dat = await User.GetInfo(message.chat.id)

#        if user_dat.registered:
#
#            Language = text["Language"]

            #if message.from_user.language_code:
            #    language = message.from_user.language_code
            #await next_menu(language, message.chat.id, message.from_user.id, user_dat)

#            await bot.send_message(message.chat.id, text=str(Language),parse_mode="HTML",reply_markup=await buttons.main_buttons1(user_dat, language, message.chat.id))
            #await bot.send_message(message.chat.id,"Информация о подписке",parse_mode="HTML",reply_markup=await main_buttons(user_dat, language))
#            connection_options = text["connection_options"]
#            await bot.send_message(message.chat.id, text=str(connection_options),reply_markup=await main_buttons(user_dat, language))


#        else:
#            try:
#                username = "@" + str(message.from_user.username)
#            except:

#                username = str(message.from_user.id)

#            await user_dat.Adduser(username,message.from_user.full_name)
#            user_dat = await User.GetInfo(message.chat.id)

            #await bot.send_message(message.chat.id,e.emojize(texts_for_bot[language]["hello_message"]),parse_mode="HTML",reply_markup=await main_buttons(user_dat,language))
            #await bot.send_message(message.chat.id,e.emojize(texts_for_bot[language]["trial_message"]))
            #Language = text["Language"]
            #await bot.send_message(message.chat.id, text=str(Language),parse_mode="HTML",reply_markup=await buttons.main_buttons1(user_dat, language, message.chat.id))


@bot.message_handler(state=MyStates.editUser, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    async with bot.retrieve_data(m.from_user.id) as data:
        tgid=data['usertgid']
    user_dat = await User.GetInfo(tgid)
    if e.demojize(m.text) == e.demojize(text['back']): #"Назад :right_arrow_curving_left:":
        await bot.reset_data(m.from_user.id)
        await bot.delete_state(m.from_user.id)
        #await bot.send_message(m.from_user.id,"Вернул вас назад!",reply_markup=await buttons.admin_buttons(language))
        await bot.send_message(m.from_user.id,e.demojize(text['return_back']),reply_markup=await buttons.admin_buttons(language))
        return
    if e.demojize(m.text) == e.demojize(text['add_time']): #"Добавить время":
        await bot.set_state(m.from_user.id,MyStates.UserAddTimeDays)
        Butt_skip = types.ReplyKeyboardMarkup(resize_keyboard=True)
        Butt_skip.add(types.KeyboardButton(e.emojize(text["skip"])))  #(e.emojize(f"Пропустить :next_track_button:")))
        #await bot.send_message(m.from_user.id,"Введите сколько дней хотите добавить:",reply_markup=Butt_skip)
        await bot.send_message(m.from_user.id,e.demojize(text["enter_days"]),reply_markup=Butt_skip)
        return

    if e.demojize(m.text) == e.demojize(text['reset_time']): #"Обнулить время":
        await bot.set_state(m.from_user.id,MyStates.editUserResetTime)
        Butt_skip = types.ReplyKeyboardMarkup(resize_keyboard=True)
        Butt_skip.add(types.KeyboardButton(e.emojize(text["yes"])))  #(e.emojize(f"Да")))
        Butt_skip.add(types.KeyboardButton(e.emojize(text["no"])))  #(e.emojize(f"Нет")))
        #await bot.send_message(m.from_user.id,"Вы уверены что хотите сбросить время для этого пользователя ?",reply_markup=Butt_skip)
        await bot.send_message(m.from_user.id,e.emojize(text["reset_time_confirm"]),reply_markup=Butt_skip)
        return


@bot.message_handler(state=MyStates.editUserResetTime, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    async with bot.retrieve_data(m.from_user.id) as data:
        tgid=data['usertgid']


    if e.demojize(m.text) == e.demojize(text['yes']):
        db = await aiosqlite.connect(DBCONNECT)
        db.row_factory = sqlite3.Row
        await db.execute(f"Update userss set subscription = ?, banned=false, notion_oneday=true where tgid=?",(str(int(time.time())), tgid))
        await db.commit()
        await bot.send_message(m.from_user.id,e.demojize(text['time_reset']))

    async with bot.retrieve_data(m.from_user.id) as data:
        usertgid = data['usertgid']
    user_dat = await User.GetInfo(usertgid)
    user_details = e.demojize(text['user_details'])
    readymes = f"{user_details} <b>{str(user_dat.fullname)}</b> ({str(user_dat.username)})\nTG-id: <code>{str(user_dat.tgid)}</code>\n\n"



    if int(user_dat.subscription) > int(time.time()):
        #readymes += e.emojize(text['subscription_datetime_active'])
        subscription_datetime_active = e.emojize(text['subscription_datetime_active'])
        readymes += f"{subscription_datetime_active} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :check_mark_button:"
    else:
        #readymes += e.emojize(text['subscription_datetime_ended'])
        subscription_datetime_ended = e.emojize(text['subscription_datetime_ended'])
        readymes += f"{subscription_datetime_ended} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :cross_mark:"
    await bot.set_state(m.from_user.id, MyStates.editUser)

    await bot.send_message(m.from_user.id, e.emojize(readymes),
                               reply_markup=await buttons.admin_buttons_edit_user(user_dat,language), parse_mode="HTML")

@bot.message_handler(state=MyStates.UserAddTimeDays, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    if e.demojize(m.text) == e.demojize(text['skip']): #"Пропустить :next_track_button:":
        days=0
    else:
        try:
            days=int(m.text)
        except:
            await bot.send_message(m.from_user.id,e.emojize(text['must_be_number'])) #"Должно быть число!\nПопробуйте еще раз.")
            return
        if days<0:
            await bot.send_message(m.from_user.id, e.emojize(text['not_negative_number']))#"Не должно быть отрицательным числом!\nПопробуйте еще раз.")
            return

    async with bot.retrieve_data(m.from_user.id) as data:
        data['days']= days
    await bot.set_state(m.from_user.id,MyStates.UserAddTimeHours)
    Butt_skip = types.ReplyKeyboardMarkup(resize_keyboard=True)
    Butt_skip.add(types.KeyboardButton(e.emojize(text['skip']))) #e.emojize(f"Пропустить :next_track_button:")))
    #await bot.send_message(m.from_user.id, "Введите сколько часов хотите добавить:", reply_markup=Butt_skip)
    await bot.send_message(m.from_user.id, e.emojize(text['enter_hours']), reply_markup=Butt_skip)


@bot.message_handler(state=MyStates.UserAddTimeHours, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    if e.demojize(m.text) == e.emojize(text['skip']): #"Пропустить :next_track_button:":
        hours=0
    else:
        try:
            hours=int(m.text)
        except:
            await bot.send_message(m.from_user.id, e.emojize(text['must_be_number'])) #"Должно быть число!\nПопробуйте еще раз.")
            return
        if hours<0:
            await bot.send_message(m.from_user.id, e.emojize(text['not_negative_number'])) #"Не должно быть отрицательным числом!\nПопробуйте еще раз.")
            return

    async with bot.retrieve_data(m.from_user.id) as data:
        data['hours']= hours
    await bot.set_state(m.from_user.id,MyStates.UserAddTimeMinutes)
    Butt_skip = types.ReplyKeyboardMarkup(resize_keyboard=True)
    Butt_skip.add(types.KeyboardButton(e.emojize(text['skip']))) #e.emojize(f"Пропустить :next_track_button:")))
    #await bot.send_message(m.from_user.id, "Введите сколько минут хотите добавить:", reply_markup=Butt_skip)
    await bot.send_message(m.from_user.id, e.demojize(text['enter_minutes']), reply_markup=Butt_skip)


@bot.message_handler(state=MyStates.UserAddTimeMinutes, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    if e.demojize(m.text) == e.emojize(text['skip']): #"Пропустить :next_track_button:":
        minutes=0
    else:
        try:
            minutes=int(m.text)
        except:
            await bot.send_message(m.from_user.id, e.emojize(text['must_be_number'])) #"Должно быть число!\nПопробуйте еще раз.")
            return
        if minutes<0:
            await bot.send_message(m.from_user.id, e.emojize(text['not_negative_number'])) #"Не должно быть отрицательным числом!\nПопробуйте еще раз.")
            return

    async with bot.retrieve_data(m.from_user.id) as data:
        data['minutes']= minutes
        hours= data['hours']
        days = data['days']
        tgid = data['usertgid']

    await bot.set_state(m.from_user.id,MyStates.UserAddTimeApprove)
    Butt_skip = types.ReplyKeyboardMarkup(resize_keyboard=True)
    Butt_skip.add(types.KeyboardButton(e.emojize(text["yes"])))
    Butt_skip.add(types.KeyboardButton(e.emojize(text["no"])))
    #await bot.send_message(m.from_user.id, f"Пользователю {str(tgid)} добавится:\n\nДни: {str(days)}\nЧасы: {str(hours)}\nМинуты: {str(minutes)}\n\nВсе верно ?", reply_markup=Butt_skip)
    user_will_be_added_user = text['user_will_be_added'][0]
    user_will_be_added_add  = text['user_will_be_added'][1]
    days = text['days']
    hours = text['hours']
    minutes = text['minutes']
    all_correct = text['all_correct']
    await bot.send_message(m.from_user.id, f"{user_will_be_added_user} {str(tgid)} {user_will_be_added_add}\n\n{days}: {str(days)}\n{hours}: {str(hours)}\n{minutes}: {str(minutes)}\n\n{all_correct}", reply_markup=Butt_skip)

@bot.message_handler(state=MyStates.UserAddTimeApprove, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    all_time=0
    if e.demojize(m.text) == e.emojize(text["yes"]):
        async with bot.retrieve_data(m.from_user.id) as data:
            minutes=data['minutes']
            hours = data['hours']
            days = data['days']
            tgid = data['usertgid']
        all_time+=minutes*60
        all_time+=hours*60*60
        all_time += days * 60 * 60*24
        await AddTimeToUser(tgid,all_time)
        await bot.send_message(m.from_user.id, e.emojize(text['time_added_to_user']), parse_mode="HTML")



    async with bot.retrieve_data(m.from_user.id) as data:
          usertgid = data['usertgid']
    user_dat = await User.GetInfo(usertgid)
    user_details = text['user_details']
    readymes = f"{user_details} <b>{str(user_dat.fullname)}</b> ({str(user_dat.username)})\nTG-id: <code>{str(user_dat.tgid)}</code>\n\n"

    if int(user_dat.subscription) > int(time.time()):
        subscription_datetime_active = text['subscription_datetime_active']
        readymes += f"{subscription_datetime_active} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :check_mark_button:"
        #readymes += f"Подписка: до <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :check_mark_button:"
    else:
        subscription_datetime_ended = text['subscription_datetime_ended']
        readymes += f"{subscription_datetime_ended} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :cross_mark:"
        #readymes += f"Подписка: закончилась <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :cross_mark:"
    await bot.set_state(m.from_user.id, MyStates.editUser)

    await bot.send_message(m.from_user.id, e.emojize(readymes),
                               reply_markup=await buttons.admin_buttons_edit_user(user_dat,language), parse_mode="HTML")



@bot.message_handler(state=MyStates.findUserViaId, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    await bot.delete_state(m.from_user.id)
    try:
        user_id=int(m.text)
    except:
        await bot.send_message(m.from_user.id, text["Invalid_Id"],reply_markup=await buttons.admin_buttons(language))
        return
    user_dat = await User.GetInfo(user_id)
    if not user_dat.registered:
        await bot.send_message(m.from_user.id, text['User_Not_Exist'], reply_markup=await buttons.admin_buttons(language))
        return

    user_details = text['user_details']
    readymes=f"{user_details} <b>{str(user_dat.fullname)}</b> ({str(user_dat.username)})\nTG-id: <code>{str(user_dat.tgid)}</code>\n\n"

    if int(user_dat.subscription)>int(time.time()):
        subscription_datetime_active = text['subscription_datetime_active']
        readymes+=f"{subscription_datetime_active} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :check_mark_button:"
    else:
        subscription_datetime_ended = text['subscription_datetime_ended']
        readymes += f"{subscription_datetime_ended} <b>{datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}</b> :cross_mark:"
    await bot.set_state(m.from_user.id,MyStates.editUser)
    async with bot.retrieve_data(m.from_user.id) as data:
        data['usertgid'] = user_dat.tgid
    await bot.send_message(m.from_user.id,e.emojize(readymes),reply_markup=await buttons.admin_buttons_edit_user(user_dat,language),parse_mode="HTML")

@bot.message_handler(state=MyStates.AdminNewUser, content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    if e.demojize(m.text) == e.demojize(text['back']): #"Назад :right_arrow_curving_left:":
        await bot.delete_state(m.from_user.id)
        return_back = text['return_back']
        await bot.send_message(m.from_user.id, return_back,reply_markup=await buttons.admin_buttons(language))
        return

    if set(m.text) <= set(string.ascii_letters+string.digits):
        db = await aiosqlite.connect(DBCONNECT)
        await db.execute(f"INSERT INTO static_profiles (name) values (?)", (m.text,))
        await db.commit()
        check = subprocess.call(f'./addusertovpn.sh {str(m.text)}', shell=True)
        await bot.delete_state(m.from_user.id)
        User_Added = text['User_Added']
        await bot.send_message(m.from_user.id,
                               User_Added, reply_markup=await buttons.admin_buttons_static_users(language))
    else:
        await bot.send_message(m.from_user.id, text['enter_username']) #"Можно использовать только латинские символы и арабские цифры!\nПопробуйте заново.")
        return


@bot.message_handler(state="*", content_types=["text"])
async def Work_with_Message(m: types.Message):

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    user_dat = await User.GetInfo(m.chat.id)


    if user_dat.registered == False:
        try:
            username = "@" + str(m.from_user.username)
        except:

            username = str(m.from_user.id)

        await user_dat.Adduser(username,m.from_user.full_name)
        #print(messages[language]["hello_message"])
        texts_for_bot = texts_for_bot[language]["hello_message"]
        await bot.send_message(m.chat.id,
                               texts_for_bot,
                               parse_mode="HTML", reply_markup=await main_buttons(user_dat,language))
        #### 000
        await bot.send_message(m.chat.id,text['Language'],parse_mode="HTML",reply_markup=await buttons.main_buttons1(user_dat, language))

        return
    await user_dat.CheckNewNickname(m)

    if m.from_user.id == CONFIG["admin_tg_id"]:
        if e.demojize(m.text) == e.demojize(text['admin_panel']): #"Админ-панель :smiling_face_with_sunglasses:":
            await bot.send_message(m.from_user.id,e.emojize(text['admin_panel']),reply_markup=await buttons.admin_buttons(language))
            return
        if e.demojize(m.text) == e.demojize(text['main_menu']): #"Главное меню :right_arrow_curving_left:":
            await bot.send_message(m.from_user.id, e.emojize(text['admin_panel']), reply_markup=await main_buttons(user_dat,language))
            return
        if e.demojize(m.text) == e.demojize(text['show_users']): #"Вывести пользователей :bust_in_silhouette:":
            #await bot.send_message(m.from_user.id, e.emojize("Выберите каких пользователей хотите вывести."),reply_markup=await buttons.admin_buttons_output_users(language))
            await bot.send_message(m.from_user.id, e.emojize(text['choose_user_type']), reply_markup=await buttons.admin_buttons_output_users(language))
            return

        if e.demojize(m.text) == e.demojize(text['back']): #"Назад :right_arrow_curving_left:":
            await bot.send_message(m.from_user.id, e.emojize(text['admin_panel']), reply_markup=await buttons.admin_buttons(language))
            return

        if e.demojize(m.text) == e.demojize(text['all_users']): #"Всех пользователей":
            allusers= await user_dat.GetAllUsers()
            readymes=""
            for i in allusers:
                if int(i[2])>int(time.time()):
                    readymes+=f"{i[6]} ({i[5]}|<code>{str(i[1])}</code>) :check_mark_button:\n"
                else:
                    readymes += f"{i[6]} ({i[5]}|<code>{str(i[1])}</code>)\n"
            await bot.send_message(m.from_user.id, e.emojize(readymes), reply_markup=await buttons.admin_buttons(language),parse_mode="HTML")
            return

        if e.demojize(m.text) == e.demojize(text['users_with_subscription']): #"Пользователей с подпиской":
            allusers=await user_dat.GetAllUsersWithSub()
            readymes=""
            if len(allusers)==0:
                await bot.send_message(m.from_user.id, e.emojize(text['no_users_with_subscription']), reply_markup=await buttons.admin_buttons(language),parse_mode="HTML")
                return
            for i in allusers:
                #print(datetime.utcfromtimestamp(int(time.time())).strftime('%d.%m.%Y %H:%M'))
                if int(i[2])>int(time.time()):
                    readymes+=f"{i[6]} ({i[5]}|<code>{str(i[1])}</code>) - {datetime.utcfromtimestamp(int(user_dat.subscription)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')}\n\n"
            await bot.send_message(m.from_user.id,e.emojize(readymes),parse_mode="HTML")
        if e.demojize(m.text) ==  e.demojize(text['output_static_users']): #"Вывести статичных пользователей":
            db = await aiosqlite.connect(DBCONNECT)
            c =  await db.execute(f"select * from static_profiles")
            all_staticusers = await c.fetchall()
            await c.close()
            await db.close()
            if len(all_staticusers)==0:
                await bot.send_message(m.from_user.id, e.emojize(text['no_static_users'])) #"Статичных пользователей нету!")
                return
            for i in all_staticusers:
                Butt_delete_account = types.InlineKeyboardMarkup()
                Butt_delete_account.add(types.InlineKeyboardButton(e.emojize(text["delete_user_btn"]), callback_data=f'DELETE:{str(i[0])}'))

                config = open(f'/root/wg0-client-{str(str(i[1]))}.conf', 'rb')
                await bot.send_document(chat_id=m.chat.id, document=config,
                                        visible_file_name=f"{str(str(i[1]))}.conf",
                                        caption=f"ID: <code>{str(i[1])}</code>", parse_mode="HTML",
                                        reply_markup=Butt_delete_account)

            return

        if e.demojize(m.text) == e.demojize(text['edit_user']): #"Редактировать пользователя по id :pencil:":
            #await bot.send_message(m.from_user.id,"Введите Telegram Id пользователя:",reply_markup=types.ReplyKeyboardRemove())
            await bot.send_message(m.from_user.id,e.emojize(text['enter_telegram_id']),reply_markup=types.ReplyKeyboardRemove())
            await bot.set_state(m.from_user.id,MyStates.findUserViaId)
            return

        if e.demojize(m.text) == e.demojize(text['static_users']): #"Статичные пользователи":
            #await bot.send_message(m.from_user.id,"Выберите пункт меню:",reply_markup=await buttons.admin_buttons_static_users(language))
            await bot.send_message(m.from_user.id,text['choose_menu_item'],reply_markup=await buttons.admin_buttons_static_users(language))
            return

        if e.demojize(m.text) == e.demojize(text['add_user']): #"Добавить пользователя :plus:":
            #await bot.send_message(m.from_user.id,"Введите имя для нового пользователя!\nМожно использовать только латинские символы и арабские цифры.",reply_markup=await buttons.admin_buttons_back(language))
            await bot.send_message(m.from_user.id,e.demojize(text['enter_username']),reply_markup=await buttons.admin_buttons_back(language))
            #await bot.set_state(m.from_user.id,MyStates.AdminNewUser)
            return

    #if text['extend'] == e.demojize(text['extend']):
    if e.demojize(m.text) == e.demojize(text['extend']):
        payment_info= await user_dat.PaymentInfo()
        # if not payment_info is None:
        #     urltopay=CONFIG["url_redirect_to_pay"]+str((await p2p.check(bill_id=payment_info['bill_id'])).pay_url)[-36:]
        #     Butt_payment = types.InlineKeyboardMarkup()
        #     Butt_payment.add(
        #         types.InlineKeyboardButton(e.emojize("Оплатить :money_bag:"), url=urltopay))
        #     Butt_payment.add(
        #         types.InlineKeyboardButton(e.emojize("Отменить платеж :cross_mark:"), callback_data=f'Cancel:'+str(user_dat.tgid)))
        #     await bot.send_message(m.chat.id,"Оплатите прошлый счет или отмените его!",reply_markup=Butt_payment)
        # else:
        if True:
            Butt_payment = types.InlineKeyboardMarkup()

            #await bot.send_message(chat_id=m.chat.id, text='<a href="https://telegra.ph/TrustyVPN---provіdnij-postachalnik-poslug-v-sferі-vіrtualnoi-privatnoi-merezhі-VPN-05-27">Договор на предоставление услуг.</a>', parse_mode="HTML")

            months = text['months']
            discount_price = text['discount']

            discount_percentage1 = float(CONFIG['discount1'])
            discounted_price1 = (1 * CONFIG['one_month_cost']) * (1 - discount_percentage1/100)
            discounted_price_formatted1 = "{:.2f}".format(discounted_price1)

            discounted1 = (1 * CONFIG['one_month_cost']) * (1 - discount_percentage1/100)
            discountedPrice1 = (1 * CONFIG['one_month_cost']) - discounted1
            discountedFormated1 = "{:.2f}".format(discountedPrice1)

            Butt_payment.add(
                    types.InlineKeyboardButton(e.emojize(f"1 {months} 📅  - {discounted_price_formatted1} $ | {discount_price} {discountedFormated1}$ -{CONFIG['discount1']}%"), callback_data="BuyMonth:1"))
                #types.InlineKeyboardButton(e.emojize(f"1 мес. 📅 - {str(1*CONFIG['one_month_cost'])} $"), callback_data="BuyMonth:1"))

            discount_percentage3 = float(CONFIG['discount3'])
            discounted_price3 = (3 * CONFIG['one_month_cost']) * (1 - discount_percentage3/100)
            discounted_price_formatted3 = "{:.2f}".format(discounted_price3)

            discounted3 = (3 * CONFIG['one_month_cost']) * (1 - discount_percentage3/100)
            discountedPrice3 = (3 * CONFIG['one_month_cost']) - discounted3
            discountedFormated3 = "{:.2f}".format(discountedPrice3)

            Butt_payment.add(
                    # {str((3 * CONFIG['one_month_cost']))}
                    types.InlineKeyboardButton(e.emojize(f"3 {months} 📅  - {discounted_price_formatted3} $ | {discount_price} {discountedFormated3}$ -{CONFIG['discount3']}%"), callback_data="BuyMonth:3"))
                #types.InlineKeyboardButton(e.emojize(f"3 мес. 📅 - {str( ( 3*CONFIG['one_month_cost'])} - ( 3 / 100 ) * float(CONFIG['discount3']) $"), callback_data="BuyMonth:3"))


            discount_percentage6 = float(CONFIG['discount6'])
            discounted_price6 = (6 * CONFIG['one_month_cost']) * (1 - discount_percentage6/100)
            discounted_price_formatted6 = "{:.2f}".format(discounted_price6)

            discounted6 = (6 * CONFIG['one_month_cost']) * (1 - discount_percentage6/100)
            discountedPrice6 = (6 * CONFIG['one_month_cost']) - discounted6
            discountedFormated6 = "{:.2f}".format(discountedPrice6)

            Butt_payment.add(
                    types.InlineKeyboardButton(e.emojize(f"6 {months} 📅  - {discounted_price_formatted6} $ | {discount_price} {discountedFormated6}$ -{CONFIG['discount6']}%"), callback_data="BuyMonth:6"))

            discount_percentage12 = float(CONFIG['discount12'])
            discounted_price12 = (12 * CONFIG['one_month_cost']) * (1 - discount_percentage12/100)
            discounted_price_formatted12 = "{:.2f}".format(discounted_price12)

            discounted12 = (12 * CONFIG['one_month_cost']) * (1 - discount_percentage12/100)
            discountedPrice12 = (12 * CONFIG['one_month_cost']) - discounted12
            discountedFormated12 = "{:.2f}".format(discountedPrice12)

            Butt_payment.add(
                    types.InlineKeyboardButton(e.emojize(f"12 {months}  📅  - {discounted_price_formatted12} $ | {discount_price} {discountedFormated12}$ -{CONFIG['discount12']}%"), callback_data="BuyMonth:12"))

            #types.InlineKeyboardButton(e.emojize(f"6 мес. 📅 - {str(6*CONFIG['one_month_cost'])} $"), callback_data="BuyMonth:6"))
            #await bot.send_message(m.chat.id, "<b>Оплатить можно с помощью Банковской карты или Qiwi кошелька!</b>\n\nВыберите на сколько месяцев хотите приобрести подписку:", reply_markup=Butt_payment,parse_mode="HTML")

            #Butt_payment.add(
            #    types.InlineKeyboardButton(e.emojize("Условия о предоставлении услуг"), url="https://telegra.ph/TrustyVPN---provіdnij-postachalnik-poslug-v-sferі-vіrtualnoi-privatnoi-merezhі-VPN-05-27"))

            #await bot.send_message(m.chat.id,
            #                       "<b>Оплатить можно с помощью Банковской карты!</b>\n\nВыберите на сколько месяцев хотите приобрести подписку:",
            #                       reply_markup=Butt_payment, parse_mode="HTML")

            await bot.send_message(m.chat.id, e.emojize(text['pay_with_card']),reply_markup=Butt_payment, parse_mode="HTML")

    print(e.demojize(text['how_to_connect_btn']) + ' ' + e.demojize(text['how_to_connect_btn']))
    #if e.demojize(text['how_to_connect_btn']) == e.demojize(text['how_to_connect_btn']):
    #if text['how_to_connect_btn'] == e.demojize(text['how_to_connect_btn']):
    if e.demojize(m.text) == e.demojize(text['how_to_connect_btn']): #"Как подключить :gear:":
        if user_dat.trial_subscription == False:
            Butt_how_to = types.InlineKeyboardMarkup()
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["android_client"]), url="https://play.google.com/store/apps/details?id=com.wireguard.android"))
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["iphone_client"]), url="https://apps.apple.com/us/app/wireguard/id1441195209"))
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["clients_all_os"]), url="https://www.wireguard.com/install/"))
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["iphone_instructions"]), url="https://telegra.ph/Gajd-na-ustanovku-WireGuard-05-26"))
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["android_instructions"]), url="https://telegra.ph/Gajd-na-ustanovku-WireGuard-Android-05-26"))
            Butt_how_to.add(
                types.InlineKeyboardButton(e.emojize(text["check_vpn"]),
                                           url="https://2ip.ua/"))
            config = open(f'/root/wg0-client-{str(user_dat.tgid)}.conf', 'rb')

            Butt_how_to.add(types.InlineKeyboardButton( e.emojize('Поддержка'), url="https://t.me/BrainByte_bot"))
            #await bot.send_document(chat_id=m.chat.id,document=config,visible_file_name=f"{str(user_dat.tgid)}.conf",caption=texts_for_bot["how_to_connect_info"],parse_mode="HTML",reply_markup=Butt_how_to)


            import qrcode
            import os
            import random
            import string

            def generate_random_name(length):
                  letters = string.ascii_lowercase
                  return ''.join(random.choice(letters) for i in range(length))

            random_name = generate_random_name(8)

            with open(f'/root/wg0-client-{str(user_dat.tgid)}.conf', 'rb') as qrimg:
                   data = qrimg.read()

            qr = qrcode.QRCode(
                version = 1,
                error_correction = qrcode.constants.ERROR_CORRECT_H,
                box_size = 10,
                border = 4,
                )

            qr.add_data(data)
            qr.make(fit=True)
            img = qr.make_image()
            img.save('/tmp/qrcode-' + random_name + '.png')

            with open(f'/root/wg0-client-{str(user_dat.tgid)}.conf', 'rb') as config_file:
                   config = config_file.read()


            await bot.send_message(chat_id=m.chat.id, text='QR Code' )
            await bot.send_photo(chat_id=m.chat.id, photo=open('/tmp/qrcode-' + random_name + '.png', 'rb') )

              #await bot.send_document(chat_id=m.chat.id, document=config, visible_file_name=f"{str(user_dat.tgid)}.conf",
              #          caption=texts_for_bot["how_to_connect_info"], parse_mode="HTML",
              #          reply_markup=Butt_how_to)

              #user_id = m.from_user.id
              #language = await get_user_language(user_id)
              #print(texts_for_bot[language])

            with open("texts.json", encoding="utf-8") as file_handler:
                    text_mess = json.load(file_handler)
                    texts_for_bot=text_mess

            texts_for_bot = texts_for_bot[language]["how_to_connect_info"]
            await bot.send_document(chat_id=m.chat.id, document=config, visible_file_name=f"{str(user_dat.tgid)}.conf",
                        caption=texts_for_bot, parse_mode="HTML",reply_markup=Butt_how_to)

            os.remove('/tmp/qrcode-' + random_name + '.png')
        else:
            await bot.send_message(chat_id=m.chat.id,text=text['purchase_subscription_first']) # "Сначала нужно купить подписку!")




@bot.callback_query_handler(func=lambda call: True)
async def Buy_month(call: types.CallbackQuery):

    chat_id = call.message.chat.id
    user_id = call.from_user.id

    import aiosqlite

    async def update_user_language(user_id, language):
        async with aiosqlite.connect(DBCONNECT) as conn:
            cur = await conn.cursor()
            await cur.execute("UPDATE userss SET language = ? WHERE tgid = ?", (language, user_id))
            await conn.commit()

    if call.message:
        if call.data == "en":
            await bot.send_message(call.message.chat.id, "You chose English")
            user_id = call.from_user.id
            await update_user_language(user_id, 'en')
            language = await get_user_language(user_id)
            print('001', language)
            call.message.from_user.language_code = language
            await start(call.message)
        elif call.data == "ru":
            await bot.send_message(call.message.chat.id, "Вы выбрали Русский")
            user_id = call.from_user.id
            await update_user_language(user_id, 'ru')
            language = await get_user_language(user_id)
            print('002', language)
            call.message.from_user.language_code = language
            await start(call.message)
        elif call.data == "uk":
            await bot.send_message(call.message.chat.id, "Ви обрали Українську")
            user_id = call.from_user.id
            await update_user_language(user_id, 'uk')
            language = await get_user_language(user_id)
            print('003', language)
            call.message.from_user.language_code = language
            await start(call.message)

    user_dat = await User.GetInfo(call.from_user.id)
    payment_info = await user_dat.PaymentInfo()

    global Month_count
    if payment_info is None:
        Month_count=int(str(call.data).split(":")[1])
        print(Month_count)
        if Month_count == 1:
           discount = CONFIG['discount1'] / 100
        elif Month_count == 3:
           discount = CONFIG['discount3'] / 100
        elif Month_count == 6:
           discount = CONFIG['discount6'] / 100
        elif Month_count == 12:
           discount = CONFIG['discount12'] / 100
        else:
           discount = 0

        user_id = call.from_user.id
        language = await get_user_language(user_id)

        vpn_on =  texts_for_bot[language]['vpn_on']
        month = texts_for_bot[language]['month']
        payment_vpn = texts_for_bot[language]['payment_vpn']

        await bot.delete_message(call.message.chat.id, call.message.id)
        amount = int(Month_count * CONFIG['one_month_cost'] * 100 * (1 - discount))

        # bill = await bot.send_invoice(call.message.chat.id, f"Оплата VPN", f"VPN на {str(Month_count)} мес.", call.data, currency="USD", prices=[types.LabeledPrice(f"VPN на {str(Month_count)} мес.", 999 )], provider_token="632593626:TEST:sandbox_i34856545622") #CONFIG["tg_shop_token"])

        bill = await bot.send_invoice(call.message.chat.id, payment_vpn, f"{vpn_on} {str(Month_count)} {month}", call.data, currency="USD", prices=[types.LabeledPrice(f"{vpn_on} {str(Month_count)} {month}", amount)], provider_token=CONFIG["tg_shop_token"])

        #bill = await bot.send_invoice(call.message.chat.id, messages[language]['payment_vpn'], f"{vpn_on} {str(Month_count)} {month}", call.data, currency="USD", prices, provider_token=CONFIG["tg_shop_token"])

        #bill = await bot.send_invoice(call.message.chat.id, f"Оплата VPN", f"VPN на {str(Month_count)} мес.", call.data, currency="USD", prices=[types.LabeledPrice(f"VPN на {str(Month_count)} мес.", amount)], provider_token=CONFIG["tg_shop_token"])

        #bill = await bot.send_invoice(call.message.chat.id,f"Оплата VPN",f"VPN на {str(Month_count)} мес.",call.data,currency="USD",prices=[types.LabeledPrice(f"VPN на {str(Month_count)} мес.", Month_count*CONFIG['one_month_cost']*100)],provider_token=CONFIG["tg_shop_token"])
        #await user_dat.NewPay(bill.,Month_count*CONFIG['one_month_cost'],Month_count*2592000,call.message.id)

        # Butt_payment = types.InlineKeyboardMarkup()
        # Butt_payment.add(
        #     types.InlineKeyboardButton(e.emojize("Оплатить :money_bag:"), url=urltopay))
        # Butt_payment.add(
        #     types.InlineKeyboardButton(e.emojize("Отменить платеж :cross_mark:"), callback_data=f'Cancel:' + str(user_dat.tgid)))
        # await bot.edit_message_text(chat_id=call.from_user.id,message_id=call.message.id,text=f"<b>Оплата: VPN на {str(Month_count)} мес.\n\nСумма оплаты: <code>{str(Month_count*CONFIG['one_month_cost'])} ₽</code></b>\nОплатите счет в течение 45 минут!",parse_mode="HTML",reply_markup=Butt_payment)




    await bot.answer_callback_query(call.id)


# @bot.callback_query_handler(func=lambda c: 'Cancel:' in c.data)
# async def Cancel_payment(call: types.CallbackQuery):
#     user_dat = await User.GetInfo(call.from_user.id)
#     payment_info = await user_dat.PaymentInfo()
#     if not payment_info is None:
#         await user_dat.CancelPayment()
#         await p2p.reject(bill_id=payment_info['bill_id'])
#
#
#     await bot.answer_callback_query(call.id)



async def AddTimeToUser(tgid,timetoadd):

    userdat = await User.GetInfo(tgid)

    user_id = tgid
    language = await get_user_language(user_id)
    text = translations[language]

    db = await aiosqlite.connect(DBCONNECT)
    db.row_factory = sqlite3.Row

    if int(userdat.subscription) < int(time.time()):
        passdat = int(time.time()) + timetoadd
        await db.execute(f"Update userss set subscription = ?, banned=false, notion_oneday=false where tgid=?",(str(int(time.time()) + timetoadd), userdat.tgid))
        check = subprocess.call(f'./addusertovpn.sh {str(userdat.tgid)}', shell=True)
        #await bot.send_message(userdat.tgid, e.emojize( 'Данны для входа были обновлены, скачайте новый файл авторизации через раздел "Как подключить :gear:"'))
        await bot.send_message(userdat.tgid, e.emojize(text['login_updated']))
    else:
        passdat = int(userdat.subscription) + timetoadd
        await db.execute(f"Update userss set subscription = ?, notion_oneday=false where tgid=?",(str(int(userdat.subscription)+timetoadd), userdat.tgid))
    await db.commit()

    Butt_main = types.ReplyKeyboardMarkup(resize_keyboard=True)
    dateto = datetime.utcfromtimestamp(int(passdat)+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')
    timenow = int(time.time())
    print(timenow)
    if int(passdat) >= timenow:
        valid_until = text['valid_until']
        Butt_main.add(
            types.KeyboardButton(e.emojize(f":green_circle: {valid_until} {dateto} :green_circle:")))

    Butt_main.add(types.KeyboardButton(e.emojize(text['extend_subscription_btn'])), #(e.emojize(f"Продлить :money_bag:")),
                  types.KeyboardButton(e.emojize(text['how_to_connect_btn']))) #(e.emojize(f"Как подключить :gear:")))

@bot.callback_query_handler(func=lambda c: 'DELETE:' in c.data or 'DELETYES:' in c.data or 'DELETNO:' in c.data)
async def DeleteUserYesOrNo(call: types.CallbackQuery):

    user_id = call.messages.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]


    idstatic = str(call.data).split(":")[1]
    db = await aiosqlite.connect(DBCONNECT)
    c = await db.execute(f"select * from static_profiles where id=?",(int(idstatic),))
    staticuser = await c.fetchone()
    await c.close()
    await db.close()
    if staticuser[0]!=int(idstatic):
        await bot.answer_callback_query(call.id, e.emojize(text['user_already_deleted'])) #"Пользователь уже удален!")
        return

    if "DELETE:" in call.data:
        Butt_delete_account = types.InlineKeyboardMarkup()
        Butt_delete_account.add(types.InlineKeyboardButton(e.emojize(text["delete"]),callback_data=f'DELETYES:{str(staticuser[0])}'),types.InlineKeyboardButton(e.emojize("Нет"),callback_data=f'DELETNO:{str(staticuser[0])}'))
        await bot.edit_message_reply_markup(call.message.chat.id,call.message.id,reply_markup=Butt_delete_account)
        await bot.answer_callback_query(call.id)
        return
    if "DELETYES:" in call.data:
        db = await aiosqlite.connect(DBCONNECT)
        await db.execute(f"delete from static_profiles where id=?", (int(idstatic),))
        await db.commit()
        await bot.delete_message(call.message.chat.id,call.message.id)
        check = subprocess.call(f'./deleteuserfromvpn.sh {str(staticuser[1])}', shell=True)
        await bot.answer_callback_query(call.id, e.emojize(text["user_deleted"])) #"Пользователь удален!")
        return
    if "DELETNO:" in call.data:
        Butt_delete_account = types.InlineKeyboardMarkup()
        Butt_delete_account.add(types.InlineKeyboardButton(e.emojize(text["delete_user_btn"]), callback_data=f'DELETE:{str(idstatic)}'))
        await bot.edit_message_reply_markup(call.message.chat.id,call.message.id,reply_markup=Butt_delete_account)
        await bot.answer_callback_query(call.id)
        return



@bot.pre_checkout_query_handler(func=lambda query: True)
async def checkout(pre_checkout_query):
    #(pre_checkout_query)

    user_id = pre_checkout_query.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    global Month_count

    if Month_count == 1:
           discount = CONFIG['discount1'] / 100
    elif Month_count == 3:
           discount = CONFIG['discount3'] / 100
    elif Month_count == 6:
           discount = CONFIG['discount6'] / 100
    elif Month_count == 12:
           discount = CONFIG['discount12'] / 100
    else:
           discount = 0


    month = int(Month_count * CONFIG['one_month_cost'] * 100 * (1 - discount))
    #month=int(str(pre_checkout_query.invoice_payload).split(":")[1])
    #if month*100*CONFIG['one_month_cost']!=pre_checkout_query.total_amount:
    if month != pre_checkout_query.total_amount:
        await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=False,
                                            error_message=text["cannot_buy_old_price"]) #"Нельзя купить по старой цене!")
        #await bot.send_message(pre_checkout_query.from_user.id,"<b>Цена изменилась! Нельзя приобрести по старой цене!</b>",parse_mode="HTML")
        await bot.send_message(pre_checkout_query.from_user.id,text['price_changed'],parse_mode="HTML")
    else:
        await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True,
                                            error_message=text['payment_failed']) #"Оплата не прошла, попробуйте еще раз!")

@bot.message_handler(content_types=['successful_payment'])
async def got_payment(m):
    payment:types.SuccessfulPayment = m.successful_payment
    month=int(str(payment.invoice_payload).split(":")[1])

    user_id = m.from_user.id
    language = await get_user_language(user_id)
    text = translations[language]

    user_dat = await User.GetInfo(m.from_user.id)
    await bot.send_message(m.from_user.id, texts_for_bot[language]["success_pay_message"],reply_markup=await buttons.main_buttons(user_dat,language),parse_mode="HTML")
    await AddTimeToUser(m.from_user.id,month*30*24*60*60)

    #await bot.send_message(userdat.tgid,"Ваша подписка обновлена!",reply_markup=Butt_main)


bot.add_custom_filter(asyncio_filters.StateFilter(bot))



# def checkPayments():
#     while True:
#         try:
#             time.sleep(5)
#             db = sqlite3.connect(DBCONNECT)
#             db.row_factory = sqlite3.Row
#             c = db.execute(f"SELECT * FROM payments")
#             log = c.fetchall()
#             c.close()
#             db.close()
#
#             if len(log)>0:
#                 p2pCheck = QiwiP2P(auth_key=QIWI_PRIV_KEY)
#                 for i in log:
#                     status = p2pCheck.check(bill_id=i["bill_id"]).status
#                     if status=="PAID":
#                         BotChecking = TeleBot(BOTAPIKEY)
#
#                         db = sqlite3.connect(DBCONNECT)
#                         db.execute(f"DELETE FROM payments where tgid=?",
#                                    (i['tgid'],))
#                         userdat=db.execute(f"SELECT * FROM userss WHERE tgid=?",(i['tgid'],)).fetchone()
#                         if int(userdat[2])<int(time.time()):
#                             passdat=int(time.time())+i["time_to_add"]
#                             db.execute(f"UPDATE userss SET subscription = ?, banned=false, notion_oneday=false where tgid=?",(str(int(time.time())+i["time_to_add"]),i['tgid']))
#                             #check = subprocess.call(f'./addusertovpn.sh {str(i["tgid"])}', shell=True)
#                             BotChecking.send_message(i['tgid'],e.emojize('Данны для входа были обновлены, скачайте новый файл авторизации через раздел "Как подключить :gear:"'))
#                         else:
#                             passdat = int(userdat[2]) + i["time_to_add"]
#                             db.execute(f"UPDATE userss SET subscription = ?, notion_oneday=false where tgid=?",
#                                        (str(int(userdat[2])+i["time_to_add"]), i['tgid']))
#                         db.commit()
#
#
#                         Butt_main = types.ReplyKeyboardMarkup(resize_keyboard=True)
#                         dateto = datetime.utcfromtimestamp(int(passdat) +CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')
#                         timenow = int(time.time())
#                         if int(passdat) >= timenow:
#                             Butt_main.add(
#                                 types.KeyboardButton(e.emojize(f":green_circle: До: {dateto} МСК:green_circle:")))
#
#                         Butt_main.add(types.KeyboardButton(e.emojize(f"Продлить :money_bag:")),
#                                       types.KeyboardButton(e.emojize(f"Как подключить :gear:")))
#
#                         BotChecking.edit_message_reply_markup(chat_id=i['tgid'],message_id=i['mesid'],reply_markup=None)
#                         BotChecking.send_message(i['tgid'],
#                                                  texts_for_bot["success_pay_message"],
#                                                  reply_markup=Butt_main)
#
#
#                     if status == "EXPIRED":
#                         BotChecking = TeleBot(BOTAPIKEY)
#                         BotChecking.edit_message_text(chat_id=i['tgid'], message_id=i['mesid'],text="Платеж просрочен.",
#                                                               reply_markup=None)
#                         db = sqlite3.connect(DBCONNECT)
#                         db.execute(f"DELETE FROM payments where tgid=?",
#                                    (i['tgid'],))
#                         db.commit()
#
#
#
#
#         except:
#             pass


def checkTime():
    while True:
        try:
            time.sleep(15)
            db = sqlite3.connect(DBCONNECT)
            db.row_factory = sqlite3.Row
            c = db.execute(f"SELECT * FROM userss")
            log = c.fetchall()
            c.close()
            db.close()
            for i in log:
                time_now=int(time.time())
                remained_time=int(i[2])-time_now
                if remained_time<=0 and i[3]==False:
                    db = sqlite3.connect(DBCONNECT)
                    db.execute(f"UPDATE userss SET banned=true where tgid=?",(i[1],))
                    db.commit()
                    check = subprocess.call(f'./deleteuserfromvpn.sh {str(i[1])}', shell=True)

                    dateto = datetime.utcfromtimestamp(int(i[2])+CONFIG['UTC_time']*3600).strftime('%d.%m.%Y %H:%M')
                    Butt_main = types.ReplyKeyboardMarkup(resize_keyboard=True)
                    Butt_main.add(
                            types.KeyboardButton(e.emojize(f":red_circle: Закончилась: {dateto} :red_circle:")))
                    Butt_main.add(types.KeyboardButton(e.emojize(f"Продлить :money_bag:")),
                                  types.KeyboardButton(e.emojize(f"Как подключить :gear:")))
                    BotChecking = TeleBot(BOTAPIKEY)
                    BotChecking.send_message(i['tgid'],
                                             texts_for_bot['ru']["ended_sub_message"],
                                             reply_markup=Butt_main,parse_mode="HTML")

                if remained_time<=86400 and i[4]==False:
                    db = sqlite3.connect(DBCONNECT)
                    db.execute(f"UPDATE userss SET notion_oneday=true where tgid=?", (i[1],))
                    db.commit()
                    BotChecking = TeleBot(BOTAPIKEY)
                    BotChecking.send_message(i['tgid'],texts_for_bot['ru']["alert_to_renew_sub"],parse_mode="HTML")








        except Exception as err:
            print(err)
            pass


if __name__ == '__main__':
    # threadPayments = threading.Thread(target=checkPayments, name="payments")
    # threadPayments.start()

    threadcheckTime = threading.Thread(target=checkTime, name="checkTime1")
    threadcheckTime.start()

    asyncio.run(bot.polling(non_stop=True, interval=0, request_timeout=60, timeout=60))
import json
